# Level 02
Moving on to the third level. This is where things start to get fun! Looking in the directory, wee see ```exploit.py overwrite overwrite.c```. As always, lets run overwrite to see what it does:

``` Bash
$ chmod +x overwrite
$ ./overwrite
yes? yes
12345678
...
```
Ok, so this is not helpful. It looks like just some random prompt. Lets try to overflow it:

``` Bash
$ ./overwrite
yes? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
61616161
...
```
This gives us a little more info. It looks like we overflowed it since 0x61 is the hex ascii value for 'a'. Lets do our normal file checks:
``` Bash
$ file overwrite
overwrite: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=094cbdd4694e5f4aeb958401302aadc77be2c5f0, for GNU/Linux 3.2.0, not stripped

$ checksec --file=overwrite
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable   FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   70 Symbols        No    0               2             overwrite
```
This looks normal. We also note this is a 32-bit binary. Time for ```ghidra```. We see two functions now! ```main``` and ```do_input```. We see that main looks like this

``` C
/* WARNING: Function: __x86.get_pc_thunk.ax replaced with injection: get_pc_thunk_ax */

undefined4 main(void)

{
  do_input();
  return 0;
}
```
and simply just calls ```do_input()``` which presumably handles our input. Lets check out that function

``` C
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */

void do_input(void)

{
  char inputBuffer [32];
  int password;
  
  password = 0x12345678;
  printf("yes? ");
  fflush(stdout);
  gets(inputBuffer);
  if (password == L'\xdeadbeef') {
    puts("good job!!");
    printf("%04x\n",password);
    fflush(stdout);
  }
  else {
    printf("%04x\n",password);
    puts("...");
    fflush(stdout);
  }
  return;
}
```
This is an interesting function. It sets up a buffer, makes a password of ```0x12345678``` and then checks if the password has magically changed to ```0xdeadbeef```. If it somehow has, then we get a "good job" printed, if not nothing fun happens. We see that our input buffer is 32 bytes and that the dangerous ```gets()``` function is used. Since this is a local variable and in 32-bit, we know that the value for this is stored directly on the stack. This means that we could potentially overflow the ```inputBuffer``` and overwrite the value of ```password```. First, we need to know a bunch of things.
