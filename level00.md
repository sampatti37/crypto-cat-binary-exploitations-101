# Level 00

This is the first level and is intended for you to understand how c code works and what the goal of binary exploitations are. In short, a binary exploitation is a flaw in the c code that allows memory to be overwritten through input from the user. This is a general definition and will get much more specific as we move on.

When we enter the 00 level we see two files:

```
vuln
vuln.c
```

Based on the files, we know that ```vuln``` is the compiled binary and ```vuln.c``` is the source code. As mentioned in the ```before-you-start``` file, try not to use the source code files unless you absolutely need to. 

The first thing when doing challenges like this is to run the binary to see what it does. Running ```$ ./vuln``` we get the following output

```
Give me data plz:

```

This is prompting us for user input. Entering my name and hitting enter, the program quits. This doesn't give us a lot of info, so lets look around a little deeper. Lets start with the file command

```
$ file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=40bfd0a2a6007a83be654c0626aedb3bc95a133f, for GNU/Linux 3.2.0, not stripped
```

The ```file``` command prints out details about the file provided. Here we see three important things. First, ```32-bit``` tells us that this is compiled using 32 bit assembly. This helps us know the size of the memory addresses among other things. Next is ```LSB executable```. This stands for least significant bit executable, or little endian. This means that data is stored with the least significant bit first. So ```0xdeadbeef``` in hex would be stored ```0xefbeadde```. Lastly, we see ```not stripped```. This tells us that this binary will disassemble and decompile nicely in gdb and ghidra.

Next, we can either use ghidra to disassemble and decompile the code, or gdb-gef to step through it. I prefer to use ghidra first, so lets fire it up by running ```ghidra```. When ghidra opens, create a new project, import the binary, double click the binary, click yes, then analyze. You will see the assembly code in the middle and info about the binary on the left. Clicking on exports, we get a list of the functions. We can scroll down and usually user defined functions will be at the bottom. Find main and click on it. We then see on the far right, the following decompilation

```
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */

undefined4 main(void)

{
  char local_20 [16];
  undefined *local_10;
  
  local_10 = &stack0x00000004;
  puts("Give me data plz: ");
  gets(local_20);
  return 0;
}
```

Here is almost an exact implementation of ```vuln.c```. The variable names dont carry over, so we can rename ```local_20``` by right clicking and renaming. This shows us that a 16 byte buffer is being created, and then is getting populated by the ```gets()``` function. the ```gets()``` function is extremely insecure as it does not take a size limit when called. Therefore, it will take in any amount of data that is passed to it. If you recompile ```vuln.c``` using

```gcc vuln.c -o vuln```

you will see a message telling you to use ```fgets()``` as opposed to ```gets()```. Seeing this, along with the code from ghidra, lets see if we can cause some unwanted behavior in the program:

```
$ ./vuln
Give me data plz:
aaaaaaaaaaaaaaaaa
zsh: segmentation fault  ./vuln
```

We know from ghidra that the buffer length is 16 bytes and that one character is a byte. If we enter 17 bytes of data (17 characters) we see that we get a segmentation fault. A segmentation fault, simply put, is an error that occurs when the executing program tries to access memory that it either does not have access to, or contains garbage data.

Why did this happen?

We can now examine the program through gdb-gef. If we type ```gdb vuln```, it will open the gdb editor and if you installed gef, it should automatically be applied. We can then type ```disas main```. This will disassemble the main function into assembly and show us all the machine instructions as well as their virtual memory address.

```
gef➤  disas main
Dump of assembler code for function main:
   0x08049172 <+0>:     lea    ecx,[esp+0x4]
   0x08049176 <+4>:     and    esp,0xfffffff0
   0x08049179 <+7>:     push   DWORD PTR [ecx-0x4]
   0x0804917c <+10>:    push   ebp
   0x0804917d <+11>:    mov    ebp,esp
   0x0804917f <+13>:    push   ebx
   0x08049180 <+14>:    push   ecx
   0x08049181 <+15>:    sub    esp,0x10
   0x08049184 <+18>:    call   0x80490b0 <__x86.get_pc_thunk.bx>
   0x08049189 <+23>:    add    ebx,0x2e77
   0x0804918f <+29>:    sub    esp,0xc
   0x08049192 <+32>:    lea    eax,[ebx-0x1ff8]
   0x08049198 <+38>:    push   eax
   0x08049199 <+39>:    call   0x8049040 <puts@plt>
   0x0804919e <+44>:    add    esp,0x10
   0x080491a1 <+47>:    sub    esp,0xc
   0x080491a4 <+50>:    lea    eax,[ebp-0x18]
   0x080491a7 <+53>:    push   eax
   0x080491a8 <+54>:    call   0x8049030 <gets@plt>
   0x080491ad <+59>:    add    esp,0x10
   0x080491b0 <+62>:    mov    eax,0x0
   0x080491b5 <+67>:    lea    esp,[ebp-0x8]
   0x080491b8 <+70>:    pop    ecx
   0x080491b9 <+71>:    pop    ebx
   0x080491ba <+72>:    pop    ebp
   0x080491bb <+73>:    lea    esp,[ecx-0x4]
   0x080491be <+76>:    ret    
End of assembler dump.
```

Highlight and copy the address of the ```ret``` or return function and set a break point there

```b *0x080491be```

This allows us to run the code and then stop it right before it executes that instruction. Then simply type ```r``` to run the program. It will again prompt you for input ```Give me data plz:``` at which point you should enter 17 characters and hit enter. Then, enter ```ni``` to step forward by just one instruction. Next, type ```info r``` to get the info for all the registers. We see the following

```
gef➤  info r
eax            0x0                 0x0
ecx            0xffff0061          0xffff0061
edx            0x1                 0x1
ebx            0xf7e1cff4          0xf7e1cff4
esp            0xffff0061          0xffff0061
ebp            0x0                 0x0
esi            0x80491c0           0x80491c0
edi            0xf7ffcb80          0xf7ffcb80
eip            0x0                 0x0
eflags         0x286               [ PF SF IF ]
cs             0x23                0x23
ss             0x2b                0x2b
ds             0x2b                0x2b
es             0x2b                0x2b
fs             0x0                 0x0
gs             0x63                0x63
gef➤ 
```

Look at the ```esp``` register. This is your stack pointer. It is pointing to a memory address of ```0xffff0061```. Does ```0x61``` look familiar? That is the ascii hex of the character ```a```. This is where the 17th ```a``` went from our input. This address is now a garbage memory address since it contains the character from our input. This is what is causing our program to seg fault. 

Thats the end of challenge 00! The goal of this challenge was to cause a seg fault in the program by inspecting the executable file. This is the beginning of binary exploitations!
